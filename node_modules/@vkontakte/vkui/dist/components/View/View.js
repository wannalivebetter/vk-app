"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.transitionEndEventName = exports.transitionStartEventName = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classNames = _interopRequireDefault(require("../../lib/classNames"));

var _animate = _interopRequireDefault(require("../../lib/animate"));

var _transitionEvents = _interopRequireDefault(require("../../lib/transitionEvents"));

var _getClassName = _interopRequireDefault(require("../../helpers/getClassName"));

var _platform = require("../../lib/platform");

var _Touch = _interopRequireDefault(require("../Touch/Touch"));

var _removeObjectKeys = _interopRequireDefault(require("../../lib/removeObjectKeys"));

var _PanelHeader = require("../PanelHeader/PanelHeader");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var baseClassNames = (0, _getClassName.default)('View');
var transitionStartEventName = 'VKUI:View:transition-start';
exports.transitionStartEventName = transitionStartEventName;
var transitionEndEventName = 'VKUI:View:transition-end';
exports.transitionEndEventName = transitionEndEventName;
var scrollsCache = {};
var swipeBackExcludedTags = ['input', 'textarea'];

var View =
/*#__PURE__*/
function (_Component) {
  _inherits(View, _Component);

  function View(props) {
    var _this;

    _classCallCheck(this, View);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(View).call(this, props));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "refsStore", {});

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "transitionEndHandler", function () {
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        manual: true
      };

      if (['animation-ios-next-forward', 'animation-ios-prev-back', 'animation-android-next-forward', 'animation-android-prev-back'].indexOf(e.animationName) > -1 || e.manual) {
        var activePanel = _this.props.activePanel;
        var isBack = _this.state.isBack;
        var prevPanel = _this.state.prevPanel;

        _this.document.dispatchEvent(new _this.window.CustomEvent(transitionEndEventName));

        _this.setState({
          prevPanel: null,
          nextPanel: null,
          visiblePanels: [activePanel],
          activePanel: activePanel,
          animated: false,
          isBack: undefined,
          scrolls: isBack ? (0, _removeObjectKeys.default)(_this.state.scrolls, [prevPanel]) : _this.state.scrolls
        }, function () {
          isBack && this.window.scrollTo(0, this.state.scrolls[activePanel]);
          this.props.onTransition && this.props.onTransition({
            isBack: isBack,
            from: prevPanel,
            to: activePanel
          });
        });
      }
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "swipingBackTransitionEndHandler", function (e) {
      // indexOf because of vendor prefixes in old browsers
      if (e.propertyName.indexOf('transform') >= 0 && e.target.classList.contains('View__panel--swipe-back-next')) {
        _this.state.swipingBackFinish ? _this.onSwipeBackSuccess() : _this.onSwipeBackCancel();
      }
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onScrollTop", function () {
      var activePanel = _this.state.activePanel;

      if (activePanel) {
        var scrollTop = _this.document.body.scrollTop || _this.document.documentElement.scrollTop;

        if (scrollTop) {
          (0, _animate.default)({
            duration: 200,
            timing: function timing(n) {
              return Math.sqrt(n);
            },
            draw: function draw(val) {
              _this.window.scrollTo(0, scrollTop - val * scrollTop);
            }
          });
        }
      }
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onMoveX", function (e) {
      if (swipeBackExcludedTags.indexOf(e.originalEvent.target.tagName.toLowerCase()) > -1) {
        return;
      }

      if (_platform.IS_PLATFORM_IOS && !_this.context.isWebView && (e.startX <= 70 || e.startX >= _this.window.innerWidth - 70) && !_this.state.browserSwipe) {
        _this.setState({
          browserSwipe: true
        });
      }

      if (_platform.IS_PLATFORM_IOS && _this.context.isWebView && _this.props.onSwipeBack) {
        if (_this.state.animated && e.startX <= 70) {
          return;
        }

        if (e.startX <= 70 && !_this.state.swipingBack && _this.props.history.length > 1) {
          _this.setState({
            swipingBack: true,
            swipebackStartX: e.startX,
            startT: e.startT,
            swipeBackPrevPanel: _this.state.activePanel,
            swipeBackNextPanel: _this.props.history.slice(-2)[0],
            scrolls: _objectSpread({}, _this.state.scrolls, _defineProperty({}, _this.state.activePanel, _this.window.pageYOffset))
          });
        }

        if (_this.state.swipingBack) {
          var swipeBackShift;

          if (e.shiftX < 0) {
            swipeBackShift = 0;
          } else if (e.shiftX > _this.window.innerWidth - _this.state.swipebackStartX) {
            swipeBackShift = _this.window.innerWidth;
          } else {
            swipeBackShift = e.shiftX;
          }

          _this.setState({
            swipeBackShift: swipeBackShift
          });
        }
      }
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onEnd", function () {
      if (_this.state.swipingBack) {
        var speed = _this.state.swipeBackShift / (new Date() - _this.state.startT) * 1000;

        if (_this.state.swipeBackShift === 0) {
          _this.onSwipeBackCancel();
        } else if (_this.state.swipeBackShift >= _this.window.innerWidth) {
          _this.onSwipeBackSuccess();
        } else {
          _this.setState({
            swipingBackFinish: speed > 250 || _this.state.swipebackStartX + _this.state.swipeBackShift > _this.window.innerWidth / 2
          });
        }
      }
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "getRef", function (c) {
      if (c && c.container && c.id) {
        var el = c;

        while (el.container) {
          el = el.container;
        }

        _this.refsStore[c.id] = el;
      }
    });

    _this.state = {
      scrolls: scrollsCache[props.id] || {},
      visiblePanels: [props.activePanel],
      activePanel: props.activePanel,
      isBack: undefined,
      prevPanel: null,
      nextPanel: null,
      swipingBack: false,
      swipebackStartX: 0,
      swipeBackShift: 0,
      swipeBackNextPanel: null,
      swipeBackPrevPanel: null,
      swipingBackFinish: null,
      browserSwipe: false
    };
    return _this;
  }

  _createClass(View, [{
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var _this2 = this;

      nextProps.popout && !this.props.popout && this.blurActiveElement();
      nextProps.modal && !this.props.modal && this.blurActiveElement(); // Нужен переход

      if (this.props.activePanel !== nextProps.activePanel && !this.state.swipingBack && !this.state.browserSwipe) {
        var firstLayer = this.panels.find(function (panel) {
          return panel.props.id === _this2.props.activePanel || panel.props.id === nextProps.activePanel;
        });
        var isBack = firstLayer && firstLayer.props.id === nextProps.activePanel;
        this.blurActiveElement();
        this.setState({
          visiblePanels: [this.props.activePanel, nextProps.activePanel],
          prevPanel: this.props.activePanel,
          nextPanel: nextProps.activePanel,
          activePanel: null,
          animated: true,
          scrolls: _objectSpread({}, this.state.scrolls, _defineProperty({}, this.props.activePanel, this.window.pageYOffset)),
          isBack: isBack
        });
      } // Закончилась анимация свайпа назад


      if (this.props.activePanel !== nextProps.activePanel && this.state.swipingBack) {
        var nextPanel = nextProps.activePanel;
        var prevPanel = this.props.activePanel;
        this.setState({
          swipeBackPrevPanel: null,
          swipeBackNextPanel: null,
          swipingBack: false,
          swipingBackFinish: null,
          swipebackStartX: 0,
          swipeBackShift: 0,
          activePanel: nextPanel,
          visiblePanels: [nextPanel],
          scrolls: (0, _removeObjectKeys.default)(this.state.scrolls, [this.state.swipeBackPrevPanel])
        }, function () {
          _this2.document.dispatchEvent(new _this2.window.CustomEvent(transitionEndEventName));

          window.scrollTo(0, _this2.state.scrolls[_this2.state.activePanel]);
          _this2.props.onTransition && _this2.props.onTransition({
            isBack: true,
            from: prevPanel,
            to: nextPanel
          });
        });
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.props.id) {
        scrollsCache[this.props.id] = this.state.scrolls;
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      var scrolls = this.state.scrolls; // Начался переход

      if (!prevState.animated && this.state.animated) {
        this.document.dispatchEvent(new this.window.CustomEvent(transitionStartEventName, {
          detail: {
            scrolls: scrolls
          }
        }));
        var nextPanelElement = this.pickPanel(this.state.nextPanel);
        var prevPanelElement = this.pickPanel(this.state.prevPanel);
        prevPanelElement.scrollTop = scrolls[this.state.prevPanel];

        if (this.state.isBack) {
          nextPanelElement.scrollTop = scrolls[this.state.nextPanel];
        }

        this.waitAnimationFinish(this.pickPanel(this.state.isBack ? this.state.prevPanel : this.state.nextPanel), this.transitionEndHandler);
      } // Начался свайп назад


      if (!prevState.swipingBack && this.state.swipingBack) {
        this.document.dispatchEvent(new this.window.CustomEvent(transitionStartEventName, {
          detail: {
            scrolls: scrolls
          }
        }));
        this.props.onSwipeBackStart && this.props.onSwipeBackStart();

        var _nextPanelElement = this.pickPanel(this.state.swipeBackNextPanel);

        var _prevPanelElement = this.pickPanel(this.state.swipeBackPrevPanel);

        _nextPanelElement.scrollTop = scrolls[this.state.swipeBackNextPanel];
        _prevPanelElement.scrollTop = scrolls[this.state.swipeBackPrevPanel];
      } // Началась анимация завершения свайпа назад.


      if (prevState.swipingBackFinish === null && this.state.swipingBackFinish !== null) {
        this.waitTransitionFinish(this.pickPanel(this.state.swipeBackNextPanel), this.swipingBackTransitionEndHandler);
      } // Если свайп назад отменился (когда пользователь недостаточно сильно свайпнул)


      if (prevState.swipingBackFinish === false && this.state.swipingBackFinish === null) {
        this.window.scrollTo(0, scrolls[this.state.activePanel]);
      } // Закончился Safari свайп


      if (prevProps.activePanel !== this.props.activePanel && this.state.browserSwipe) {
        this.setState({
          browserSwipe: false,
          nextPanel: null,
          prevPanel: null,
          animated: false,
          visiblePanels: [this.props.activePanel],
          activePanel: this.props.activePanel
        });
      }
    }
  }, {
    key: "waitTransitionFinish",
    value: function waitTransitionFinish(elem, eventHandler) {
      if (_transitionEvents.default.supported) {
        var eventName = _transitionEvents.default.prefix ? _transitionEvents.default.prefix + 'TransitionEnd' : 'transitionend';
        elem.removeEventListener(eventName, eventHandler);
        elem.addEventListener(eventName, eventHandler);
      } else {
        setTimeout(eventHandler.bind(this), _platform.IS_PLATFORM_ANDROID ? 300 : 600);
      }
    }
  }, {
    key: "waitAnimationFinish",
    value: function waitAnimationFinish(elem, eventHandler) {
      if (_transitionEvents.default.supported) {
        var eventName = _transitionEvents.default.prefix ? _transitionEvents.default.prefix + 'AnimationEnd' : 'animationend';
        elem.removeEventListener(eventName, eventHandler);
        elem.addEventListener(eventName, eventHandler);
      } else {
        setTimeout(eventHandler.bind(this), _platform.IS_PLATFORM_ANDROID ? 300 : 600);
      }
    }
  }, {
    key: "blurActiveElement",
    value: function blurActiveElement() {
      if (typeof this.window !== 'undefined' && this.document.activeElement) {
        this.document.activeElement.blur();
      }
    }
  }, {
    key: "pickPanel",
    value: function pickPanel(id) {
      var elem = this.document.getElementById(id);

      if (!elem) {
        console.warn("Element #".concat(id, " not found"));
      }

      return elem && elem.parentNode.parentNode;
    }
  }, {
    key: "onSwipeBackSuccess",
    value: function onSwipeBackSuccess() {
      this.props.onSwipeBack && this.props.onSwipeBack();
    }
  }, {
    key: "onSwipeBackCancel",
    value: function onSwipeBackCancel() {
      var _this3 = this;

      this.setState({
        swipeBackPrevPanel: null,
        swipeBackNextPanel: null,
        swipingBack: false,
        swipingBackFinish: null,
        swipebackStartX: 0,
        swipeBackShift: 0
      }, function () {
        _this3.document.dispatchEvent(new _this3.window.CustomEvent(transitionEndEventName));
      });
    }
  }, {
    key: "calcPanelSwipeStyles",
    value: function calcPanelSwipeStyles(panelId) {
      var isPrev = panelId === this.state.swipeBackPrevPanel;
      var isNext = panelId === this.state.swipeBackNextPanel;

      if (!isPrev && !isNext || this.state.swipingBackFinish !== null) {
        return {};
      }

      var prevPanelTranslate = "".concat(this.state.swipeBackShift, "px");
      var nextPanelTranslate = "".concat(-50 + this.state.swipeBackShift * 100 / this.window.innerWidth / 2, "%");
      var prevPanelShadow = 0.3 * (this.window.innerWidth - this.state.swipeBackShift) / this.window.innerWidth;

      if (this.state.swipingBackFinish !== null) {
        return isPrev ? {
          boxShadow: "-2px 0 12px rgba(0, 0, 0, ".concat(prevPanelShadow, ")")
        } : {};
      }

      if (isNext) {
        return {
          transform: "translate3d(".concat(nextPanelTranslate, ", 0, 0)"),
          WebkitTransform: "translate3d(".concat(nextPanelTranslate, ", 0, 0)")
        };
      }

      if (isPrev) {
        return {
          transform: "translate3d(".concat(prevPanelTranslate, ", 0, 0)"),
          WebkitTransform: "translate3d(".concat(prevPanelTranslate, ", 0, 0)"),
          boxShadow: "-2px 0 12px rgba(0, 0, 0, ".concat(prevPanelShadow, ")")
        };
      }

      return {};
    }
  }, {
    key: "calcHeaderSwipeStyles",
    value: function calcHeaderSwipeStyles(panelId) {
      var isPrev = panelId === this.state.swipeBackPrevPanel;
      var isNext = panelId === this.state.swipeBackNextPanel;

      if (!isPrev && !isNext || this.state.swipingBackFinish !== null) {
        return {
          title: {},
          bg: {},
          left: {},
          addon: {},
          right: {}
        };
      }

      var opacity = this.state.swipeBackShift / this.window.innerWidth;
      var titleTransform = this.state.swipeBackShift / this.window.innerWidth * 30;
      var leftTransform = this.state.swipeBackShift / this.window.innerWidth * 30;

      if (isNext) {
        return {
          title: {
            transform: "translate3d(".concat(-30 + titleTransform, "vw, 0, 0)"),
            WebkitTransform: "translate3d(".concat(-30 + titleTransform, "vw, 0, 0)"),
            opacity: opacity
          },
          left: {
            opacity: opacity
          },
          addon: {
            opacity: 1,
            transform: "translate3d(".concat(-30 + leftTransform, "vw, 0, 0)"),
            WebkitTransform: "translate3d(".concat(-30 + leftTransform, "vw, 0, 0)")
          },
          right: {
            opacity: opacity
          }
        };
      }

      if (isPrev) {
        return {
          title: {
            transform: "translate3d(".concat(titleTransform, "vw, 0, 0)"),
            WebkitTransform: "translate3d(".concat(titleTransform, "vw, 0, 0)"),
            opacity: 1 - opacity
          },
          bg: {
            opacity: 1 - opacity
          },
          left: {
            opacity: 1 - opacity
          },
          addon: {
            transform: "translate3d(".concat(leftTransform, "vw, 0, 0)"),
            WebkitTransform: "translate3d(".concat(leftTransform, "vw, 0, 0)"),
            opacity: 1 - opacity
          }
        };
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      var _this$props = this.props,
          style = _this$props.style,
          popout = _this$props.popout,
          modal = _this$props.modal,
          header = _this$props.header;
      var _this$state = this.state,
          prevPanel = _this$state.prevPanel,
          nextPanel = _this$state.nextPanel,
          activePanel = _this$state.activePanel,
          swipeBackPrevPanel = _this$state.swipeBackPrevPanel,
          swipeBackNextPanel = _this$state.swipeBackNextPanel,
          swipingBackFinish = _this$state.swipingBackFinish;
      var hasPopout = !!popout;
      var hasModal = !!modal;
      var panels = this.panels.filter(function (panel) {
        var panelId = panel.props.id;
        return _this4.state.visiblePanels.indexOf(panelId) > -1 || panelId === swipeBackPrevPanel || panelId === swipeBackNextPanel;
      });
      var modifiers = {
        'View--header': header,
        'View--animated': this.state.animated,
        'View--swiping-back': this.state.swipingBack
      };
      return _react.default.createElement(_Touch.default, {
        component: "section",
        className: (0, _classNames.default)(baseClassNames, modifiers),
        style: style,
        onMoveX: this.onMoveX,
        onEnd: this.onEnd
      }, header && _react.default.createElement("div", {
        className: "View__header"
      }, _platform.IS_PLATFORM_IOS && _react.default.createElement("div", {
        className: "View__header-scrolltop",
        onClick: this.onScrollTop
      }), _react.default.createElement("div", {
        className: (0, _classNames.default)(_PanelHeader.baseClassNames)
      }, panels.map(function (panel) {
        var panelId = panel.props.id;

        var headerSwipeStyles = _this4.calcHeaderSwipeStyles(panelId);

        return _react.default.createElement("div", {
          className: (0, _classNames.default)('PanelHeader__in', {
            'PanelHeader__in--active': panelId === activePanel,
            'PanelHeader__in--prev': panelId === prevPanel,
            'PanelHeader__in--next': panelId === nextPanel,
            'PanelHeader__in--swipe-back-prev': panelId === swipeBackPrevPanel,
            'PanelHeader__in--swipe-back-next': panelId === swipeBackNextPanel,
            'PanelHeader__in--swipe-back-success': swipingBackFinish === true,
            'PanelHeader__in--swipe-back-failed': swipingBackFinish === false
          }),
          key: panelId,
          id: "panel-header-".concat(panelId)
        }, _react.default.createElement("div", {
          className: "PanelHeader__bg",
          key: panelId,
          id: "header-bg-".concat(panelId),
          style: headerSwipeStyles.bg
        }), _react.default.createElement("div", {
          className: "PanelHeader__container"
        }, _react.default.createElement("div", {
          className: "PanelHeader__left"
        }, _react.default.createElement("div", {
          className: "PanelHeader__left-in",
          id: "header-left-".concat(panelId),
          style: headerSwipeStyles.left
        }), _platform.IS_PLATFORM_IOS && _react.default.createElement("div", {
          className: "PanelHeader__addon",
          id: "header-addon-".concat(panelId),
          style: headerSwipeStyles.icon
        })), _react.default.createElement("div", {
          className: "PanelHeader__content",
          style: headerSwipeStyles.title,
          id: "header-title-".concat(panelId)
        }), _react.default.createElement("div", {
          className: "PanelHeader__right",
          id: "header-right-".concat(panelId),
          style: headerSwipeStyles.right
        })));
      }))), _react.default.createElement("div", {
        className: "View__panels"
      }, panels.map(function (panel) {
        var panelId = panel.props.id;
        return _react.default.createElement("div", {
          className: (0, _classNames.default)('View__panel', {
            'View__panel--active': panelId === activePanel,
            'View__panel--prev': panelId === prevPanel,
            'View__panel--next': panelId === nextPanel,
            'View__panel--swipe-back-prev': panelId === swipeBackPrevPanel,
            'View__panel--swipe-back-next': panelId === swipeBackNextPanel,
            'View__panel--swipe-back-success': swipingBackFinish === true,
            'View__panel--swipe-back-failed': swipingBackFinish === false
          }),
          style: _this4.calcPanelSwipeStyles(panelId),
          key: panelId
        }, _react.default.createElement("div", {
          className: "View__panel-in"
        }, panel));
      })), hasPopout && _react.default.createElement("div", {
        className: "View__popout"
      }, popout), hasModal && _react.default.createElement("div", {
        className: "View__modal"
      }, modal));
    }
  }, {
    key: "document",
    get: function get() {
      return this.context.document || document;
    }
  }, {
    key: "window",
    get: function get() {
      return this.context.window || window;
    }
  }, {
    key: "panels",
    get: function get() {
      return [].concat(this.props.children);
    }
  }]);

  return View;
}(_react.Component);

exports.default = View;

_defineProperty(View, "propTypes", {
  style: _propTypes.default.object,
  activePanel: _propTypes.default.string,
  header: _propTypes.default.oneOfType([_propTypes.default.object, _propTypes.default.bool]),
  children: _propTypes.default.node,
  popout: _propTypes.default.node,
  modal: _propTypes.default.node,
  onTransition: _propTypes.default.func,

  /**
   * @ignore
   */
  onSwipeBack: _propTypes.default.func,

  /**
   * @ignore
   */
  onSwipeBackStart: _propTypes.default.func,

  /**
   * @ignore
   */
  history: _propTypes.default.arrayOf(_propTypes.default.string),
  id: _propTypes.default.string
});

_defineProperty(View, "defaultProps", {
  style: {},
  children: null,
  popout: null,
  header: true,
  history: []
});

_defineProperty(View, "contextTypes", {
  isWebView: _propTypes.default.bool,
  window: _propTypes.default.any,
  document: _propTypes.default.any
});
//# sourceMappingURL=View.js.map