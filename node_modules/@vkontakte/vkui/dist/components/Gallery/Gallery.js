"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _getClassName = _interopRequireDefault(require("../../helpers/getClassName"));

var _Touch = _interopRequireDefault(require("../Touch/Touch"));

var _classNames = _interopRequireDefault(require("../../lib/classNames"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var baseClassNames = (0, _getClassName.default)('Gallery');

var Gallery =
/*#__PURE__*/
function (_Component) {
  _inherits(Gallery, _Component);

  function Gallery(props) {
    var _this;

    _classCallCheck(this, Gallery);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Gallery).call(this, props));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "go", function (targetIndex) {
      _this.setState({
        animation: true,
        shiftX: _this.calculateIndent(targetIndex),
        current: targetIndex
      });

      if (_this.timeout) {
        _this.clearTimeout();

        _this.setTimeout(_this.props.autoplay);
      }
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onStart", function (e) {
      _this.setState({
        animation: false,
        startT: e.startT
      });
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onMoveX", function (e) {
      if (!_this.isDraggable()) {
        return;
      }

      e.originalEvent.preventDefault();

      if (e.isSlideX) {
        _this.props.onDragStart && _this.props.onDragStart();

        if (_this.state.deltaX !== e.shiftX || _this.state.dragging !== e.isSlideX) {
          _this.setState({
            deltaX: e.shiftX,
            dragging: e.isSlideX
          });
        }

        return true;
      }
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onEnd", function (e) {
      var targetIndex = e.isSlide ? _this.getTarget() : _this.state.current;
      _this.props.onDragEnd && _this.props.onDragEnd();

      _this.setState({
        shiftX: _this.calculateIndent(targetIndex),
        deltaX: 0,
        animation: true,
        current: targetIndex
      });

      if (_this.props.onEnd) {
        _this.props.onEnd({
          targetIndex: targetIndex
        });
      }

      if (_this.timeout) {
        _this.clearTimeout();

        _this.setTimeout(_this.props.autoplay);
      }

      return true;
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onResize", function () {
      _this.initializeSlides();

      var _this$state = _this.state,
          layerWidth = _this$state.layerWidth,
          slides = _this$state.slides;
      var containerWidth = _this.container.current.offsetWidth;
      var viewportWidth = _this.viewport.offsetWidth;

      _this.setState({
        shiftX: _this.calculateIndent(_this.state.current),
        containerWidth: containerWidth,
        min: _this.calcMin({
          layerWidth: layerWidth,
          containerWidth: containerWidth,
          viewportWidth: viewportWidth,
          slides: slides
        }),
        max: _this.calcMax({
          layerWidth: layerWidth,
          containerWidth: containerWidth,
          viewportWidth: viewportWidth,
          slides: slides
        }),
        animation: false
      }, function () {
        window.requestAnimationFrame(function () {
          return _this.setState({
            animation: true
          });
        });
      });
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "setTimeout", function (duration) {
      _this.timeout = setTimeout(function () {
        var _this$state2 = _this.state,
            slides = _this$state2.slides,
            current = _this$state2.current;
        var targetIndex = current < slides.length - 1 ? current + 1 : 0;

        _this.go(targetIndex);
      }, duration);
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "clearTimeout", function () {
      clearTimeout(_this.timeout);
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "reduceChildren", function (acc, item, i) {
      if (item) {
        var ref = _this.getSlideRef(i);

        acc.push(_react.default.createElement("div", {
          className: "Gallery__slide",
          key: "slide-".concat(i),
          ref: ref
        }, item));
      }

      return acc;
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "getSlideRef", function (id) {
      return function (slide) {
        _this.slidesStore["slide-".concat(id)] = slide;
      };
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "getViewportRef", function (viewport) {
      _this.viewport = viewport ? viewport.container : {};
    });

    var _current = typeof props.slideIndex === 'number' ? props.slideIndex : props.initialSlideIndex;

    _this.state = {
      containerWidth: 0,
      current: _current,
      deltaX: 0,
      shiftX: 0,
      slides: [],
      animation: false,
      duration: 0.24
    };
    _this.container = _react.default.createRef();
    _this.slidesStore = {};
    _this.slides = _this.getChildren(props.children);
    return _this;
  }

  _createClass(Gallery, [{
    key: "initializeSlides",
    value: function initializeSlides() {
      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};
      var slides = this.getSlidesCoords();
      var containerWidth = this.container.current.offsetWidth;
      var viewportWidth = this.viewport.offsetWidth;
      var layerWidth = slides.reduce(function (val, slide) {
        return slide.width + val;
      }, 0);
      var min = this.calcMin({
        containerWidth: containerWidth,
        layerWidth: layerWidth,
        viewportWidth: viewportWidth,
        slides: slides
      });
      var max = this.calcMax({
        containerWidth: containerWidth,
        layerWidth: layerWidth,
        viewportWidth: viewportWidth,
        slides: slides
      });
      this.setState({
        min: min,
        max: max,
        layerWidth: layerWidth,
        containerWidth: containerWidth,
        slides: slides
      }, callback);
    }
  }, {
    key: "calcMin",
    value: function calcMin(_ref) {
      var containerWidth = _ref.containerWidth,
          layerWidth = _ref.layerWidth,
          viewportWidth = _ref.viewportWidth,
          slides = _ref.slides;

      switch (this.props.align) {
        case 'left':
          return containerWidth - layerWidth;

        case 'right':
          return viewportWidth - layerWidth;

        case 'center':
          if (this.isCenterWithCustomWidth && slides.length) {
            var _slides = slides[slides.length - 1],
                coordX = _slides.coordX,
                width = _slides.width;
            return viewportWidth / 2 - coordX - width / 2;
          } else {
            return viewportWidth - (containerWidth - viewportWidth) / 2 - layerWidth;
          }

      }
    }
  }, {
    key: "calcMax",
    value: function calcMax(_ref2) {
      var viewportWidth = _ref2.viewportWidth,
          slides = _ref2.slides;

      if (this.isCenterWithCustomWidth && slides.length) {
        var _slides$ = slides[0],
            width = _slides$.width,
            coordX = _slides$.coordX;
        return viewportWidth / 2 - coordX - width / 2;
      } else {
        return 0;
      }
    }
    /**
     * Считает отступ слоя галереи
     * @param {Number} targetIndex ID целевого слайда
     * @returns {Number} Значения отступа
     */

  }, {
    key: "calculateIndent",
    value: function calculateIndent(targetIndex) {
      var slides = this.state.slides;

      if (!this.isDraggable()) {
        return 0;
      }

      var targetSlide = slides.length ? slides[targetIndex] : null;

      if (targetSlide) {
        var coordX = targetSlide.coordX,
            width = targetSlide.width;

        if (this.isCenterWithCustomWidth) {
          var viewportWidth = this.viewport.offsetWidth;
          return viewportWidth / 2 - coordX - width / 2;
        }

        return this.validateIndent(-1 * coordX);
      } else {
        return 0;
      }
    }
    /**
     * Считает отступ слоя галереи во время драга
     * @returns {Number} Значения отступа
     */

  }, {
    key: "calculateDragIndent",
    value: function calculateDragIndent() {
      var _this$state3 = this.state,
          shiftX = _this$state3.shiftX,
          deltaX = _this$state3.deltaX,
          min = _this$state3.min,
          max = _this$state3.max;
      var indent = shiftX + deltaX;

      if (indent > max) {
        return max + Number((indent - max) / 3);
      } else if (indent < min) {
        return min + Number((indent - min) / 3);
      }

      return indent;
    }
  }, {
    key: "validateIndent",
    value: function validateIndent(value) {
      var _this$state4 = this.state,
          min = _this$state4.min,
          max = _this$state4.max;

      if (value < min) {
        return min;
      } else if (value > max) {
        return max;
      }

      return value;
    }
  }, {
    key: "isDraggable",
    value: function isDraggable() {
      return this.state.layerWidth > this.state.containerWidth;
    }
    /**
     * Получает координаты и размеры каждого слайда
     * @returns {Array} Массив с объектами, описывающими габариты слайда
     */

  }, {
    key: "getSlidesCoords",
    value: function getSlidesCoords() {
      var _this2 = this;

      return [].concat(this.props.children).reduce(function (acc, item, i) {
        if (item) {
          var elem = _this2.slidesStore["slide-".concat(i)];

          var res = {
            coordX: elem.offsetLeft,
            width: elem.offsetWidth
          };
          acc.push(res);
        }

        return acc;
      }, []);
    }
    /**
     * Получает индекс слайда, к которому будет осуществлен переход
     * @returns {Number} Индекс слайда
     */

  }, {
    key: "getTarget",
    value: function getTarget() {
      var _this$state5 = this.state,
          slides = _this$state5.slides,
          current = _this$state5.current,
          deltaX = _this$state5.deltaX,
          shiftX = _this$state5.shiftX,
          startT = _this$state5.startT,
          max = _this$state5.max;
      var expectDeltaX = deltaX / (new Date() - startT) * 240 * 0.6;
      var shift = shiftX + deltaX + expectDeltaX - max;
      var direction = deltaX < 0 ? 1 : -1; // Находим ближайшую границу слайда к текущему отступу

      var targetIndex = slides.reduce(function (val, item, index) {
        var previousValue = Math.abs(slides[val].coordX + shift);
        var currentValue = Math.abs(item.coordX + shift);
        return previousValue < currentValue ? val : index;
      }, current);

      if (targetIndex === current) {
        var targetSlide = current + direction;

        if (targetSlide >= 0 && targetSlide < slides.length) {
          if (Math.abs(deltaX) > slides[targetSlide].width * 0.05) {
            targetIndex = targetSlide;
          }
        }
      }

      return targetIndex;
    }
  }, {
    key: "getChildren",
    value: function getChildren(children) {
      return [].concat(children || this.props.children).reduce(this.reduceChildren, []);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this3 = this;

      this.initializeSlides(function () {
        _this3.setState({
          shiftX: _this3.calculateIndent(_this3.state.current)
        });
      });
      window.addEventListener('resize', this.onResize);

      if (this.props.autoplay) {
        this.setTimeout(this.props.autoplay);
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      if (this.isChildrenDirty) {
        this.isChildrenDirty = false;
        this.initializeSlides();
      }

      if (prevState.current !== this.state.current && this.props.onChange) {
        this.props.onChange(this.state.current);
      }
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      this.slides = this.getChildren(nextProps.children);
      this.isChildrenDirty = true;

      if (nextProps.autoplay && !this.props.autoplay) {
        if (nextProps.autoplay) {
          this.setTimeout(nextProps.autoplay);
        }
      }

      if (!nextProps.autoplay && this.props.autoplay) {
        this.clearTimeout();
      }

      if (nextProps.slideIndex !== this.props.slideIndex && typeof nextProps.slideIndex === 'number') {
        this.go(nextProps.slideIndex);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.removeEventListener('resize', this.onResize);
      this.clearTimeout();
    }
  }, {
    key: "render",
    value: function render() {
      var _this$state6 = this.state,
          animation = _this$state6.animation,
          duration = _this$state6.duration,
          current = _this$state6.current,
          dragging = _this$state6.dragging;

      var _this$props = this.props,
          children = _this$props.children,
          slideWidth = _this$props.slideWidth,
          autoplay = _this$props.autoplay,
          initialSlideIndex = _this$props.initialSlideIndex,
          slideIndex = _this$props.slideIndex,
          onDragStart = _this$props.onDragStart,
          onDragEnd = _this$props.onDragEnd,
          onChange = _this$props.onChange,
          onEnd = _this$props.onEnd,
          align = _this$props.align,
          bullets = _this$props.bullets,
          className = _this$props.className,
          restProps = _objectWithoutProperties(_this$props, ["children", "slideWidth", "autoplay", "initialSlideIndex", "slideIndex", "onDragStart", "onDragEnd", "onChange", "onEnd", "align", "bullets", "className"]);

      var indent = dragging ? this.calculateDragIndent() : this.calculateIndent(current);
      var layerStyle = {
        WebkitTransform: "translateX(".concat(indent, "px)"),
        transform: "translateX(".concat(indent, "px)"),
        WebkitTransition: animation ? "-webkit-transform ".concat(duration, "s cubic-bezier(.1, 0, .25, 1)") : 'none',
        transition: animation ? "transform ".concat(duration, "s cubic-bezier(.1, 0, .25, 1)") : 'none'
      };
      return _react.default.createElement("div", _extends({
        className: (0, _classNames.default)(baseClassNames, className, "Gallery--".concat(align), {
          'Gallery--dragging': dragging,
          'Gallery--custom-width': slideWidth === 'custom'
        })
      }, restProps, {
        ref: this.container
      }), _react.default.createElement(_Touch.default, {
        className: "Gallery__viewport",
        onStartX: this.onStart,
        onMoveX: this.onMoveX,
        onEnd: this.onEnd,
        style: {
          width: slideWidth === 'custom' ? '100%' : slideWidth
        },
        ref: this.getViewportRef
      }, _react.default.createElement("div", {
        className: "Gallery__layer",
        style: layerStyle
      }, this.slides)), bullets && _react.default.createElement("div", {
        className: (0, _classNames.default)('Gallery__bullets', "Gallery__bullets--".concat(bullets))
      }, this.slides.map(function (item, index) {
        return _react.default.createElement("div", {
          className: (0, _classNames.default)('Gallery__bullet', {
            'Gallery__bullet--active': index === current
          }),
          key: index
        });
      })));
    }
  }, {
    key: "isCenterWithCustomWidth",
    get: function get() {
      return this.props.slideWidth === 'custom' && this.props.align === 'center';
    }
  }]);

  return Gallery;
}(_react.Component);

exports.default = Gallery;

_defineProperty(Gallery, "propTypes", {
  children: _propTypes.default.node,
  className: _propTypes.default.string,
  style: _propTypes.default.object,
  slideWidth: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
  autoplay: _propTypes.default.number,
  initialSlideIndex: _propTypes.default.number,
  slideIndex: _propTypes.default.number,
  onDragStart: _propTypes.default.func,
  onDragEnd: _propTypes.default.func,
  onChange: _propTypes.default.func,
  onEnd: _propTypes.default.func,
  align: _propTypes.default.oneOf(['left', 'center', 'right']),
  bullets: _propTypes.default.oneOf(['dark', 'light', false])
});

_defineProperty(Gallery, "defaultProps", {
  slideWidth: '100%',
  children: '',
  autoplay: 0,
  initialSlideIndex: 0,
  align: 'left',
  bullets: false
});
//# sourceMappingURL=Gallery.js.map